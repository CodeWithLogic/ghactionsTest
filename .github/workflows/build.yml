name: Build / Release

on:
  workflow_dispatch:
    inputs:
      operation:
        description: "Choose operation"
        required: true
        type: choice
        options:
          - "Build only"
          - "Build & Deploy"
          - "Deploy"
        default: "Build only"
      release_tag:
        description: "[Deploy] Existing release tag (e.g., productservice-1.0.0)"
        required: false
      manual_env:
        description: "Target env: e1, e2, or e3 (deploys sequentially up to that env)"
        required: false
        default: "e1"

concurrency:
  group: release-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  # ===========================================
  # BUILD PATH (Build only / Build & Deploy)
  # ===========================================
  pipeline:
    if: ${{ github.event.inputs.operation != 'Deploy' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      image: ${{ steps.checksums.outputs.image }}
      digest: ${{ steps.checksums.outputs.digest }}
      release_tag: ${{ steps.derive.outputs.release_tag }}
      version: ${{ steps.derive.outputs.release_version }}
    env:
      DOCKERFILE_PATH: Dockerfile
      BUILD_PATH: .

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Setup Java & Maven"
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: "Setup Maven"
        uses: stCarolas/setup-maven@v4.5
        with:
          maven-version: 3.9.9

      - name: "Install tools (xmllint, jq)"
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils jq

      - name: "Derive artifactId/version"
        id: derive
        shell: bash
        run: |
          set -euo pipefail
          ARTIFACT_ID=$(xmllint --xpath "//*[local-name()='project']/*[local-name()='artifactId']/text()" pom.xml)
          RAW_VERSION=$(xmllint --xpath "//*[local-name()='project']/*[local-name()='version']/text()" pom.xml)
          RELEASE_VERSION="${RAW_VERSION%-SNAPSHOT}"
          IFS='.' read -r MAJ MIN PAT <<< "${RELEASE_VERSION}"; PAT=${PAT:-0}; NEXT_VERSION="${MAJ}.${MIN}.$((PAT+1))-SNAPSHOT"
          RELEASE_TAG="${ARTIFACT_ID}-${RELEASE_VERSION}"
          {
            echo "artifact_id=$ARTIFACT_ID"
            echo "raw_version=$RAW_VERSION"
            echo "release_version=$RELEASE_VERSION"
            echo "next_version=$NEXT_VERSION"
            echo "release_tag=$RELEASE_TAG"
          } >> "$GITHUB_OUTPUT"

      - name: "Decide mode"
        id: flags
        shell: bash
        run: |
          OP="${{ github.event.inputs.operation }}"
          echo "op=$OP" >> "$GITHUB_OUTPUT"
          if [[ "$OP" == "Build & Deploy" ]]; then
            echo "is_release=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_release=false" >> "$GITHUB_OUTPUT"
          fi

      # ---------- Build only ----------
      - name: "Build (snapshot)"
        if: ${{ steps.flags.outputs.op == 'Build only' }}
        run: mvn -q -DskipTests -U clean package

      - name: "Upload build artifact (snapshot)"
        if: ${{ steps.flags.outputs.op == 'Build only' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.derive.outputs.artifact_id }}-${{ steps.derive.outputs.raw_version }}-build-${{ github.run_number }}
          path: "**/target/*"
          if-no-files-found: error

      # ---------- Build & Deploy (release) ----------
      - name: "Guard: branch must be main"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          test "${GITHUB_REF_NAME}" = "main" || { echo "::error::Releases only from main"; exit 1; }

      - name: "Guard: POM must be *-SNAPSHOT before release"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          case "${{ steps.derive.outputs.raw_version }}" in
            *-SNAPSHOT) : ;;
            *) echo "::error::raw_version must end with -SNAPSHOT; found ${{ steps.derive.outputs.raw_version }}"; exit 1 ;;
          esac

      - name: "Guard: tag must not already exist"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          if git ls-remote --exit-code --tags origin "refs/tags/${{ steps.derive.outputs.release_tag }}" >/dev/null 2>&1; then
            echo "::error::Tag ${{ steps.derive.outputs.release_tag }} already exists"; exit 1
          fi

      - name: "Set version to RELEASE and commit"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          mvn -B versions:set -DnewVersion='${{ steps.derive.outputs.release_version }}'
          mvn -B versions:commit
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add pom.xml
          git commit -m "Release ${{ steps.derive.outputs.artifact_id }} ${{ steps.derive.outputs.release_version }}" || echo "No changes to commit"

      - name: "Create & push annotated tag"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          git tag -a "${{ steps.derive.outputs.release_tag }}" -m "Release ${{ steps.derive.outputs.release_tag }}"
          git push origin "${GITHUB_REF_NAME}"
          git push origin "${{ steps.derive.outputs.release_tag }}"

      - name: "Build (release)"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: mvn -q -DskipTests -U clean package

      - name: "Locate artifact (tar preferred, jar fallback)"
        id: artifact
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          BASE_TAR="${{ steps.derive.outputs.artifact_id }}-${{ steps.derive.outputs.release_version }}.tar.gz"
          BASE_JAR="${{ steps.derive.outputs.artifact_id }}-${{ steps.derive.outputs.release_version }}.jar"
          TAR_PATH="$(find . -type f -path '*/target/*' -name "$BASE_TAR" | head -n 1 || true)"
          if [[ -n "$TAR_PATH" ]]; then
            echo "artifact_path=$TAR_PATH" >> "$GITHUB_OUTPUT"; exit 0
          fi
          JAR_PATH="$(find . -type f -path '*/target/*' -name "$BASE_JAR" | head -n 1 || true)"
          if [[ -n "$JAR_PATH" ]]; then
            echo "artifact_path=$JAR_PATH" >> "$GITHUB_OUTPUT"; exit 0
          fi
          echo "::error::Neither $BASE_TAR nor $BASE_JAR found under */target/*"; exit 1

      - name: "Set up Docker Buildx"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: "Build local image (no push)"
        id: docker_local
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.BUILD_PATH }}
          file: ${{ env.DOCKERFILE_PATH }}
          push: false
          load: true
          tags: |
            local/${{ steps.derive.outputs.artifact_id }}:${{ steps.derive.outputs.release_version }}
            local/${{ steps.derive.outputs.artifact_id }}:${{ steps.derive.outputs.release_tag }}
          provenance: false

      - name: "Compute checksums (local image ID + tar/jar sha256)"
        id: checksums
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          IMG="local/${{ steps.derive.outputs.artifact_id }}:${{ steps.derive.outputs.release_version }}"
          IMAGE_ID="$(docker inspect --format='{{.Id}}' "$IMG")"
          echo "$IMG@$IMAGE_ID" | tee image-digest.txt
          sha256sum "${{ steps.artifact.outputs.artifact_path }}" | tee tar-sha256.txt
          echo "image=$IMG"   >> "$GITHUB_OUTPUT"
          echo "digest=$IMAGE_ID" >> "$GITHUB_OUTPUT"
          jq -n --arg artifactId "${{ steps.derive.outputs.artifact_id }}" \
                --arg version "${{ steps.derive.outputs.release_version }}" \
                --arg commit "${GITHUB_SHA}" \
                --arg image "$IMG" \
                --arg imageId "$IMAGE_ID" \
                --arg artifactPath "${{ steps.artifact.outputs.artifact_path }}" \
                --arg buildTime "$(date -u +%FT%TZ)" \
                '{artifactId:$artifactId, version:$version, commit:$commit, image:$image, imageId:$imageId, artifact:$artifactPath, built_at:$buildTime}' \
            > release.json

      - name: "Create GitHub Release (attach tar/jar + checksums + metadata)"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.derive.outputs.release_tag }}
          name: ${{ steps.derive.outputs.release_tag }}
          body: |
            Automated release **${{ steps.derive.outputs.release_tag }}**

            Local image reference + ID:
            ```
            ${{ steps.checksums.outputs.image }}@${{ steps.checksums.outputs.digest }}
            ```

            **Artifact checksum (SHA256)** attached in `tar-sha256.txt`.  
            Machine-readable metadata in `release.json`.
          files: |
            ${{ steps.artifact.outputs.artifact_path }}
            image-digest.txt
            tar-sha256.txt
            release.json

      - name: "Bump to next -SNAPSHOT and push"
        if: ${{ steps.flags.outputs.is_release == 'true' }}
        run: |
          mvn -B versions:set -DnewVersion='${{ steps.derive.outputs.next_version }}'
          mvn -B versions:commit
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add pom.xml
          git commit -m "Bump version to ${{ steps.derive.outputs.next_version }}" || echo "No changes"
          git push origin "${GITHUB_REF_NAME}"

  # ===========================================
  # DEPLOY PATH (from an existing tag)
  # ===========================================
  fetch_release:
    if: ${{ github.event.inputs.operation == 'Deploy' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image:  ${{ steps.extract.outputs.image }}
      digest: ${{ steps.extract.outputs.digest }}
      version: ${{ steps.extract.outputs.version }}
    steps:
      - name: "Guard: release_tag provided"
        run: |
          test -n "${{ github.event.inputs.release_tag }}" || { echo "::error::Please provide input release_tag"; exit 1; }

      - name: "Install jq"
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: "Download release assets"
        uses: robinraju/release-downloader@v1
        with:
          tag: ${{ github.event.inputs.release_tag }}
          fileName: |
            image-digest.txt
            tar-sha256.txt
            release.json
          tarBall: false
          zipBall: false

      - name: "Extract image + digest from assets"
        id: extract
        shell: bash
        run: |
          set -euo pipefail
          IMAGE=""; DIGEST=""; VERSION=""
          if [[ -f release.json ]]; then
            IMAGE=$(jq -r '.image // empty' release.json)
            DIGEST=$(jq -r '.digest // .imageId // empty' release.json)
            VERSION=$(jq -r '.version // empty' release.json)
          fi
          if [[ -z "$IMAGE" && -f image-digest.txt ]]; then
            IMAGE=$(cut -d'@' -f1 image-digest.txt || true)
            DIGEST=$(cut -d'@' -f2 image-digest.txt || true)
          fi
          [[ -n "$IMAGE" && -n "$DIGEST" ]] || { echo "::error::Could not resolve image/digest from release assets"; exit 1; }
          echo "image=$IMAGE"   >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

  deploy_e1:
    if: ${{ github.event.inputs.operation == 'Deploy' && (github.event.inputs.manual_env == 'e1' || github.event.inputs.manual_env == 'e2' || github.event.inputs.manual_env == 'e3') }}
    needs: [fetch_release]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image matches release (e1)"
        shell: bash
        run: |
          set -euo pipefail
          echo "e1 will deploy: ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"
      - name: "Deploy to e1 (dummy)"
        run: echo "Pretend deploy e1 with ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"

  deploy_e2:
    if: ${{ github.event.inputs.operation == 'Deploy' && (github.event.inputs.manual_env == 'e2' || github.event.inputs.manual_env == 'e3') }}
    needs: [fetch_release, deploy_e1]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image matches release (e2)"
        shell: bash
        run: |
          set -euo pipefail
          echo "e2 will deploy: ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"
      - name: "Deploy to e2 (dummy)"
        run: echo "Pretend deploy e2 with ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"

  deploy_e3:
    if: ${{ github.event.inputs.operation == 'Deploy' && github.event.inputs.manual_env == 'e3' }}
    needs: [fetch_release, deploy_e2]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image matches release (e3)"
        shell: bash
        run: |
          set -euo pipefail
          echo "e3 will deploy: ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"
      - name: "Deploy to e3 (dummy)"
        run: echo "Pretend deploy e3 with ${{ needs.fetch_release.outputs.image }}@${{ needs.fetch_release.outputs.digest }}"

  # ===========================================
  # BUILD-&-DEPLOY PATH (same run, after build)
  # ===========================================
  bd_deploy_e1:
    if: ${{ github.event.inputs.operation == 'Build & Deploy' && (github.event.inputs.manual_env == 'e1' || github.event.inputs.manual_env == 'e2' || github.event.inputs.manual_env == 'e3') }}
    needs: [pipeline]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image from build (e1)"
        run: echo "e1 will deploy: ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"
      - name: "Deploy to e1 (dummy)"
        run: echo "Pretend deploy e1 with ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"

  bd_deploy_e2:
    if: ${{ github.event.inputs.operation == 'Build & Deploy' && (github.event.inputs.manual_env == 'e2' || github.event.inputs.manual_env == 'e3') }}
    needs: [pipeline, bd_deploy_e1]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image from build (e2)"
        run: echo "e2 will deploy: ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"
      - name: "Deploy to e2 (dummy)"
        run: echo "Pretend deploy e2 with ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"

  bd_deploy_e3:
    if: ${{ github.event.inputs.operation == 'Build & Deploy' && github.event.inputs.manual_env == 'e3' }}
    needs: [pipeline, bd_deploy_e2]
    runs-on: ubuntu-latest
    steps:
      - name: "Gate: ensure image from build (e3)"
        run: echo "e3 will deploy: ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"
      - name: "Deploy to e3 (dummy)"
        run: echo "Pretend deploy e3 with ${{ needs.pipeline.outputs.image }}@${{ needs.pipeline.outputs.digest }}"
